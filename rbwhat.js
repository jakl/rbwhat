// Generated by CoffeeScript 1.7.1
(function() {
  var allowedAge, client, colorName, config, configDefaults, configPath, formatDate, formatHeading, fs, loadExistingConfig, main, mergeUnsetKeys, moment, needsReview, printActiveRequest, querystringify, rbapi, rbapiReviewRequests, rbapiReviews, syncConfig, tooOld;

  require('colors');

  moment = require('moment');

  querystringify = (require('querystring')).stringify;

  client = new (require('node-rest-client')).Client();

  fs = require('fs');

  configPath = process.env.HOME + '/.rbwhat.json';

  config = {};

  configDefaults = {
    user: 'test',
    url: 'https://reviewboard.twitter.biz/',
    daysOld: 14,
    filter: {
      status: 'pending',
      'to-groups': 'intl-eng-test'
    }
  };

  main = function() {
    syncConfig();
    return rbapiReviewRequests(config.filter, printActiveRequest);
  };

  printActiveRequest = function(request) {
    var submitter;
    submitter = request.links.submitter.title;
    return rbapiReviews(request.id, function(reviews) {
      var date, needs_review, output, review, reviewer, _i, _len;
      needs_review = config.user !== submitter && !tooOld(request.time_added);
      output = formatHeading(submitter, request);
      for (_i = 0, _len = reviews.length; _i < _len; _i++) {
        review = reviews[_i];
        date = review.timestamp;
        reviewer = review.links.user.title;
        needs_review = needsReview(reviewer, submitter, needs_review, date);
        output.push('    ' + colorName(reviewer, submitter, review.ship_it) + ' ' + formatDate(date));
      }
      if (needs_review) {
        return console.log(output.join('\n'));
      }
    });
  };

  needsReview = function(reviewer, submitter, needs_review, date) {
    if (config.user === reviewer) {
      return false;
    } else if (tooOld(date)) {
      return false;
    } else if (reviewer === submitter) {
      return true;
    } else if (submitter === config.user) {
      return true;
    } else {
      return needs_review;
    }
  };

  formatHeading = function(submitter, request) {
    var url;
    url = "" + config.url + "r/" + request.id + "/diff";
    return ["" + (colorName(submitter, submitter)) + ": " + request.summary.yellow, "  " + url.underline + " " + (formatDate(request.time_added))];
  };

  formatDate = function(date) {
    return moment(new Date(date)).fromNow().cyan;
  };

  tooOld = function(date) {
    return new Date(date) < allowedAge();
  };

  allowedAge = function() {
    var date;
    date = new Date();
    date.setDate(date.getDate() - config.daysOld);
    return date;
  };

  colorName = function(name, submitter, shipit) {
    switch (name) {
      case config.user:
        return name.cyan;
      case submitter:
        return name.magenta;
      default:
        if (shipit) {
          return name.green;
        } else {
          return name.red;
        }
    }
  };

  rbapi = function(path, args, cb) {
    var query;
    query = '?' + querystringify(args);
    return client.get(config.url + path + query, function(res) {
      return cb(JSON.parse(res));
    });
  };

  rbapiReviewRequests = function(filter, cb) {
    return rbapi('api/review-requests/', filter, function(res) {
      return res.review_requests.forEach(cb);
    });
  };

  rbapiReviews = function(id, cb) {
    return rbapi("api/review-requests/" + id + "/reviews/", null, function(res) {
      return cb(res.reviews);
    });
  };

  syncConfig = function() {
    if (fs.existsSync(configPath)) {
      loadExistingConfig();
    }
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    if (config.user === 'test') {
      return console.log('Set options in ~/.rbwhat.json');
    }
  };

  loadExistingConfig = function() {
    config = JSON.parse(fs.readFileSync(configPath).toString());
    mergeUnsetKeys(config, configDefaults);
    if (config.group != null) {
      config.filter['to-groups'] = config.group;
      return delete config.group;
    }
  };

  mergeUnsetKeys = function(child, template) {
    var key, _i, _len, _ref, _results;
    child.__proto__ = template;
    _ref = Object.keys(template);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      _results.push(child[key] = child[key]);
    }
    return _results;
  };

  main();

}).call(this);
